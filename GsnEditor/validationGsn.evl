// NamedElement constraints
context GSN!NamedElement {
	constraint NameNotEmpty {
		check :
	        self.name <> ""
	    message :
			"Name cannot be empty."
	}
}
	
// Supported constraints
context GSN!SupportedBy {
	// Valid SupportedBy source
	constraint SB_ValidSource {
		check :
			self.source.isKindOf(GSN!Goal) or self.source.isKindOf(GSN!Strategy)
		message :
			"Invalid SupportedBy source."
	}
		
	// Valid SupportedBy target
	constraint SB_ValidTarget {
		check :
			self.target.isKindOf(GSN!Goal) or self.target.isKindOf(GSN!Strategy) or self.target.isKindOf(GSN!Solution)
		message :
			"Invalid SupportedBy target."
	}
		
	// Valid SupportedBy connection (check when the target and source are valid)
	constraint ValidSB {
		guard :
			self.satisfies("SB_ValidSource") and self.satisfies("SB_ValidTarget")
	    check :
	        // Goal could be supported by Strategy or Solution
	        (self.source.isKindOf(GSN!Goal) and (self.target.isKindOf(GSN!Strategy) or self.target.isKindOf(GSN!Solution)))
	        or
	        // Strategy only could be supported by sub-goals
	        (self.source.isKindOf(GSN!Strategy) and self.target.isKindOf(GSN!Goal))
	    message :
	        "Invalid SupportedBy connection."
	}
}
	
	
// InContextOf constraints
context GSN!InContextOf {
	// Valid InContextOf source
	constraint ICO_ValidSource {
		check :
			self.source.isKindOf(GSN!Goal) or self.source.isKindOf(GSN!Strategy)
		message :
			"Invalid InContextOf source."
	}
		
	// Valid InContextOf target
	constraint ICO_ValidTarget {
		check :
			self.target.isKindOf(GSN!Context) or self.target.isKindOf(GSN!Assumption) or self.target.isKindOf(GSN!Justification)
		message :
			"Invalid InContextOf target."
	}
}

context GSN!Goal {
	constraint ValidDeveloped {
		guard :
			self.developed = true
    	check :
      		GSN!SupportedBy.allInstances().exists(sb | sb.source = self and sb.target.isKindOf(GSN!Strategy))
    	message :
      		"A developed goal must be supported by a Strategy."
	}

	// Argument completeness constraints
	// Every argument path must end in solution
	constraint ArgumentComplete {
		// Top-level Goal
		guard :
			GSN!SupportedBy.allInstances().select(sb | sb.target = self).isEmpty()
		check :
			self.isArgumentComplete(Sequence{})
		message :
			"The argument path does not end in a Solution."	
	}
}
	
operation GSN!NamedElement isArgumentComplete(visited : Sequence) : Boolean {
	if (visited.includes(self)) {
		return false;
	}
	
	var newVisited = visited.including(self);

    var sbLinks = GSN!SupportedBy.allInstances().select(sb | sb.source = self);

    if (sbLinks.isEmpty()) {
        return false; 
    }

    if (self.isKindOf(GSN!Goal)) {
        return sbLinks.forAll(sb |
            sb.target.isKindOf(GSN!Solution)
            or (sb.target.isKindOf(GSN!Strategy) and sb.target.isArgumentComplete(newVisited))
        );
    }
	
    if (self.isKindOf(GSN!Strategy)) {
        return sbLinks.forAll(sb |
            sb.target.isKindOf(GSN!Goal) and sb.target.isArgumentComplete(newVisited)
        );
    }
    return false;
}

